///////////////////////////////////////////////////////////
//  GameClientCommunication.cs
//  Implementation of the Class GameClientCommunication
//  Generated by Enterprise Architect
//  Created on:      04-maj-2013 21:51:53
//  Original author: Filip
///////////////////////////////////////////////////////////


using System;
using System.IO;
using System.IO.Pipes;
using System.Threading;


namespace ClientCommunication
{
    public class GameClientCommunication : IClientCommunication_Game
    {
        private IMessageQueueAdd _messageQueue;

        private PipeStream pipeClientIn;
        private PipeStream pipeClientOut;
        private StreamWriter _streamWriter;

        public GameClientCommunication(string pipeIn, string pipeOut, IMessageQueueAdd messageQueue)
        {
            _messageQueue = messageQueue;

            if (pipeIn != "NOPIPE" && pipeOut != "NOPIPE")
            {
                pipeClientIn = new AnonymousPipeClientStream(PipeDirection.In, pipeIn);
                pipeClientOut = new AnonymousPipeClientStream(PipeDirection.Out, pipeOut);

                Thread myNewThread = new Thread(() => RecieverThread(pipeClientIn, _messageQueue));
                myNewThread.Start();
                _streamWriter = new StreamWriter(pipeClientOut);
            }
            else
                //throw new Exception("Could not connnect to game");
                return;
        }


        /// 
        /// <param name="message"></param>
        public void Send(string message)
        {
            Thread myNewThread = new Thread(() => SenderThread(pipeClientOut, message, _streamWriter));
            myNewThread.Start();
        }


        private void RecieverThread(PipeStream pipeClientIn, IMessageQueueAdd mMessageQueue)
        {
            StreamReader sr = new StreamReader(pipeClientIn);
            for (;;)
            {
                string receivedString = sr.ReadLine();
                mMessageQueue.InsertMessage(receivedString);
            }
        }


        private void SenderThread(PipeStream pipeClientOut, string message, StreamWriter sWriter)
        {
            sWriter.AutoFlush = true;
            sWriter.WriteLine(message);
            pipeClientOut.WaitForPipeDrain();
        }
    }

//end GameClientCommunication
}